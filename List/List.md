# Listとは
データを箱に並べて、中に入っている値には番号（インデックス）が割り当てられている。たとえば、動物のリストがあるとき、
インデックスを使用してリストから特定の名前を取得したり、追加、削除したりすることができる。

## 例
```python
str = "Hello World!";

for i in range(0, len(str)):
    print(str[i])

```
配列は、連続した形でメモリに保存され、その位置はデータサイズとインデックスに基づく簡単な数式で計算できるため、配列内を高速にアクセスすることができる。

## 配列の注意点

1. 配列は固定されており、配列に格納されたデータは置き換えることはできるが、宣言された項目は削除できない
2. 配列のサイズ以上に要素を追加する場合、大きなサイズである新しい配列を追加し、新しい配列にコピーする必要があるため、O（n）の時間がかかる
3. 配列は連続したメモリ構造を持っているため、配列の値の取得にはO（1）の時間がかかる。ベースアドレス +（インデックス × データサイズ）の式を使うことで、インデックスはメモリから直接値を取得することができる。このように、要素に同じ時間でアクセスできることを、ランダムアクセス、またはダイレクトアクセスと呼ぶ。
4. 配列内では、一種類のデータ型のみをしようすることができる。コンパイラがデータをメモリに格納するためには、同じサイズのデータである必要があるため。


# 動的配列

配列を宣言する際、配列サイズを知る必要があるが、宣言後にサイズを拡大したり縮小したりすることはできない。問題を解決するには、大きなの新しい配列を作る必要がある。
このように格納されている要素数に応じて、自動的に大きくしたり小さくしたりできるデータ構造として動的配列という。
メリットして要素の保存やアクセスを効率的に行うことができ、また、配列のデータを操作するためのメソッドや演算子が用意されており、要素の挿入や削除、検索などを行うことができる。

```python
def printArray(arr):
    for value in arr:
        # end = " " 改行ではなく同じ行に出力
        print(value, end =" ")
    print()

dArr = [2,3,4,1,-10,200]

printArray(dArr)

dArr.append(10)
dArr.append(340)

```
## 先頭へ挿入
動的配列の先頭に要素を挿入するには既存のすべての要素を 1 つずつずらし、新しい要素のためのスペースを確保する必要があるが、配列が大きい場合には、時間のかかる。
計算としてn個の要素がある場合、n 個の要素を移動させる必要があるため、結果として O(n) の計算コストがかかる。

## 先頭の削除
先頭の要素を削除する場合は、n-1 個の要素を 1 スロット後ろ方向に移動させる必要があるため、O(n) の計算コストが必要

## 途中への挿入
n 個の要素の動的配列の中央へ要素の挿入を行う場合、先先頭に要素を挿入する場合と同じ処理を配列の真ん中まで行えば良いので、したがって、0.5n 個の要素を移動させる必要があり、 O(n) の計算コストが必要になる。

## 削除
動的配列の真ん中から要素を削除する場合、(0.5n - 1 )回の移動が必要となるので、同様に O(n) の計算コストが必要になる。

## 末端への挿入
配列の末端に要素を挿入する処理は、配列の論理サイズと収容可能サイズを考慮して処理が実行される。配列の容量が最大の論理サイズ = 収容可能サイズであるならば新しい配列を作成し、配列のn 個のデータと新しく追加したデータを
合わせた計 n+1 個の要素を、その新しい配列にコピー。したがって、O(n) の計算コストが必要となる。


## 末端の削除
配列の末尾から要素を削除はO(1) の計算量が発生する。






