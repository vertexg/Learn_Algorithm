# Listとは
データを箱に並べて、中に入っている値には番号（インデックス）が割り当てられている。たとえば、動物のリストがあるとき、
インデックスを使用してリストから特定の名前を取得したり、追加、削除したりすることができる。

## 例
```python
str = "Hello World!";

for i in range(0, len(str)):
    print(str[i])

```
配列は、連続した形でメモリに保存され、その位置はデータサイズとインデックスに基づく簡単な数式で計算できるため、配列内を高速にアクセスすることができる。

## 配列の注意点

1. 配列は固定されており、配列に格納されたデータは置き換えることはできるが、宣言された項目は削除できない
2. 配列のサイズ以上に要素を追加する場合、大きなサイズである新しい配列を追加し、新しい配列にコピーする必要があるため、O（n）の時間がかかる
3. 配列は連続したメモリ構造を持っているため、配列の値の取得にはO（1）の時間がかかる。ベースアドレス +（インデックス × データサイズ）の式を使うことで、インデックスはメモリから直接値を取得することができる。このように、要素に同じ時間でアクセスできることを、ランダムアクセス、またはダイレクトアクセスと呼ぶ。
4. 配列内では、一種類のデータ型のみをしようすることができる。コンパイラがデータをメモリに格納するためには、同じサイズのデータである必要があるため。


# 動的配列

配列を宣言する際、配列サイズを知る必要があるが、宣言後にサイズを拡大したり縮小したりすることはできない。問題を解決するには、大きなの新しい配列を作る必要がある。
このように格納されている要素数に応じて、自動的に大きくしたり小さくしたりできるデータ構造として動的配列という。
メリットして要素の保存やアクセスを効率的に行うことができ、また、配列のデータを操作するためのメソッドや演算子が用意されており、要素の挿入や削除、検索などを行うことができる。

```python
def printArray(arr):
    for value in arr:
        # end = " " 改行ではなく同じ行に出力
        print(value, end =" ")
    print()

dArr = [2,3,4,1,-10,200]

printArray(dArr)

dArr.append(10)
dArr.append(340)

```
## 先頭へ挿入
動的配列の先頭に要素を挿入するには既存のすべての要素を 1 つずつずらし、新しい要素のためのスペースを確保する必要があるが、配列が大きい場合には、時間のかかる。
計算としてn個の要素がある場合、n 個の要素を移動させる必要があるため、結果として O(n) の計算コストがかかる。

## 先頭の削除
先頭の要素を削除する場合は、n-1 個の要素を 1 スロット後ろ方向に移動させる必要があるため、O(n) の計算コストが必要

## 途中への挿入
n 個の要素の動的配列の中央へ要素の挿入を行う場合、先先頭に要素を挿入する場合と同じ処理を配列の真ん中まで行えば良いので、
したがって、0.5n 個の要素を移動させる必要があり、 O(n) の計算コストが必要になる。

## 削除
動的配列の真ん中から要素を削除する場合、(0.5n - 1 )回の移動が必要となるので、同様に O(n) の計算コストが必要になる。

## 末端への挿入
配列の末端に要素を挿入する処理は、配列の論理サイズと収容可能サイズを考慮して処理が実行される。
配列の容量が最大の論理サイズ = 収容可能サイズであるならば新しい配列を作成し、配列のn 個のデータと新しく追加したデータを
合わせた計 n+1 個の要素を、その新しい配列にコピー。したがって、O(n) の計算コストが必要となる。


## 末端の削除
配列の末尾から要素を削除はO(1) の計算量が発生する。


# 探索
リストの中で特定のデータを見つけるには、リストの探索が必要


# 連想配列
文字列やその他のキーをインデックスとして使用するデータ構造である。
またハッシュ関数と呼ばれる関数を使いキーを取り込んで、ハッシュ値またはハッシュコードと呼ばれる固定サイズの出力を生成し、配列内のキーを識別するために使用されることで
　連想配列内の値を効率的に検索することができる

 ``` python
易的なハッシュ関数を作成し、文字列を数字に変換
def simpleHash(inputString):
    numberRepresentation = 0
    for char in inputString:
        # ord は文字列の先頭バイトを、0 から 255 までの値に変換します
        numberRepresentation += ord(char)
    return numberRepresentation

print(simpleHash("myawesomestring"))

```
## HashMap
ハッシュマップとは、ハッシュ関数を用いてキーと値を対応付けるデータ構造で、キーは通常文字列で、値は任意のデータ型にすることができる。
ハッシュマップを使うと、インデックスを使う時と同様に、時間計算量 O(1) で要素にアクセスすることができます

## キャッシュ
キャッシュは、データを一時的に保持し、将来そのデータへのアクセスが必要になった際に迅速に応答できるようにするためのハードウェアやソフトウェアの機能であり
この仕組みは、利用されるデータへのアクセス速度を高めることで、全体のシステム性能の向上に寄与する。

``` python
import math

# エラトステネスのふるいのアルゴリズム
def allNPrimesSieve(n):
    # サイズnのブール値trueを持つリストを生成します。キャッシュ
    cache = [True] * n
    # ステップを√n回繰り返します。nが素数でないと仮定すると、n = a * bと表すことができるので、aとbの両方が√n 以上になることはありえません。
    # したがって、√n * √n = n は最大合成組み合わせになります。
    for currentPrime in range(2, math.ceil(math.sqrt(n))):
        # キャッシュ内の素数(p)の倍数をすべてfalseにしていきます。
        # iは2からスタートします。
        if not cache[currentPrime]: continue
        i = 2
        ip = i * currentPrime
        while ip < n:
            cache[ip] = False
            # i*pをアップデートします。
            i += 1
            ip = i * currentPrime

    # キャッシュ内のすべてのtrueのインデックスは素数です。
    primeNumbers = []
    # enumerateは現在の位置のペアの値を返します．
    for index, predicate in enumerate(cache):
        if predicate: primeNumbers.append(index)

    return primeNumbers[2:]
```
## 動的計画法
キャッシュを使うことによって再帰的な問題を解決する方法を動的計画法と呼び、複雑な問題を扱いやすい部分問題として分割し、重複する部分問題の不必要な計算を避けることによって効率化を図るという手法
動的計画法を実装する方法として、メモ化,タビュレーションの 2 種類があります。

### タビュレーション
タビュレーションとは、動的計画法において、過去に解いた部分問題の結果を表に格納して問題を解く手法のことであり、再帰的な関数呼び出しを回避し、アルゴリズムの時間計算量を低減することを目的としている。。

```python
# 木構造の結果を下から上にキャッシュする方法をタビュレーションと呼びます
def tabulationFib(n):
    # これはキャッシュであり、計算済みのフィボナッチ数をすべて保存します
    # 全てを 0 に設定します
    cache = [0] * (n+1)

    # fib0 は 0、fib1 は 1 であり、他のすべての数は fib(n) = fib(n-1) + fib(n-2) を使って求めることができます
    cache[0] = 0
    cache[1] = 1

    # 反復を使って全ての数を求めます
    for i in range(2, n+1):
        cache[i] = cache[i-1] + cache[i-2]

    # n 番目のフィボナッチを返します
    return cache[n]

print(tabulationFib(50))7

```
## ハッシュテーブル
キーと配列のインデックスを関連付けるために使われるデータ構造であり、この関連付けは、ハッシュ関数を使って行われる。
ハッシュ関数は、キーを入力、ハッシュ値という整数を出力し、ハッシュ値を配列のインデックスとして使用することで、ハッシュテーブルから素早く値を取り出すことができる。

``` python
def existsWithinList(listL,dataY):
    hashMap = {}

    # ハッシュマップに格納
    for i in range(int(len(listL))):
        hashMap[str(listL[i])] = listL[i]

    # 存在したら True、存在しなければ False
    return False if hashMap.get(str(dataY)) is None else True

sampleList = [3,10,23,3,4,50,2,3,4,18,6,1,-2]
print(existsWithinList(sampleList,23))

```











